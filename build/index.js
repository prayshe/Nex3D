/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./app/index.ts":
/*!**********************!*\
  !*** ./app/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/algebra */ \"./lib/algebra.ts\");\n/* harmony import */ var _lib_camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/camera */ \"./lib/camera.ts\");\n/* harmony import */ var _lib_light__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/light */ \"./lib/light.ts\");\n/* harmony import */ var _lib_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/loader */ \"./lib/loader.ts\");\n/* harmony import */ var _lib_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/shader */ \"./lib/shader.ts\");\n/* harmony import */ var _lib_shadow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/shadow */ \"./lib/shadow.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nfunction Main(canvasId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const canvas = document.getElementById(canvasId);\n        const gl = canvas.getContext(\"webgl2\");\n        const lightShader = new _lib_shader__WEBPACK_IMPORTED_MODULE_4__.Shader(gl, new _lib_shader__WEBPACK_IMPORTED_MODULE_4__.ColorShader);\n        const shadowShader = new _lib_shader__WEBPACK_IMPORTED_MODULE_4__.Shader(gl, new _lib_shader__WEBPACK_IMPORTED_MODULE_4__.ShadowShader);\n        canvas.height = canvas.clientHeight;\n        canvas.width = canvas.clientWidth;\n        const loader = new _lib_loader__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader(gl);\n        const floor = _lib_loader__WEBPACK_IMPORTED_MODULE_3__.BasicLoader.loadPlane(gl);\n        const fox = yield loader.load(\"../assets/fox.glb\");\n        floor.matrix = (0,_lib_algebra__WEBPACK_IMPORTED_MODULE_0__.zoom)([20, 20, 20]);\n        fox.matrix = (0,_lib_algebra__WEBPACK_IMPORTED_MODULE_0__.zoom)([15, 15, 15]);\n        const models = [floor, fox];\n        const light = new _lib_light__WEBPACK_IMPORTED_MODULE_2__.Light(100, [1, 1, 1], [-5, 30, 10]);\n        const camera = new _lib_camera__WEBPACK_IMPORTED_MODULE_1__.Camera()\n            .setAspect(canvas.width / canvas.height)\n            .setPosition([35, 20, 20])\n            .setTarget([0, 5, 0])\n            .setUp([0, 1, 0])\n            .setNear(0.1)\n            .setFar(1000)\n            .setController(canvas);\n        function ortho() {\n            const o = (0,_lib_algebra__WEBPACK_IMPORTED_MODULE_0__.orthogonal)(-200, 200, -200, 200, 1, 100);\n            const l = (0,_lib_algebra__WEBPACK_IMPORTED_MODULE_0__.lookAt)(light.position, [0, 0, 0], [0, 1, 0]);\n            return (0,_lib_algebra__WEBPACK_IMPORTED_MODULE_0__.multiply)(o, l);\n        }\n        const shadow = new _lib_shadow__WEBPACK_IMPORTED_MODULE_5__[\"default\"](gl);\n        function renderFrame(timestamp) {\n            const t = timestamp / 5000;\n            //light.setPosition([Math.sin(t * 6) * 10, 10, Math.cos(t * 6) * 10])\n            gl.viewport(0, 0, canvas.width, canvas.height);\n            gl.clearColor(0, 0, 0, 1);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            gl.enable(gl.DEPTH_TEST);\n            gl.enable(gl.CULL_FACE);\n            gl.cullFace(gl.BACK);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            lightShader.use();\n            lightShader.setMatrix(\"camera\", camera.getMatrix());\n            lightShader.setVector3(\"color\", light.getColor());\n            lightShader.draw([light.model]);\n            const c = 100;\n            const shadowMap = shadow.cast(gl, models, ortho(), c);\n            gl.viewport(0, 0, canvas.width, canvas.height);\n            gl.clearColor(0, 0, 0, 1);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            gl.enable(gl.DEPTH_TEST);\n            gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_2D, shadowMap);\n            shadowShader.use();\n            shadowShader.setMatrix(\"camera\", camera.getMatrix());\n            shadowShader.setVector3(\"Ks\", [0.7, 0.7, 0.7]);\n            shadowShader.setVector4(\"lightPos\", [...light.position, 0]);\n            shadowShader.setVector3(\"cameraPos\", camera.position);\n            shadowShader.setVector3(\"lightIntensity\", light.getColor());\n            shadowShader.setMatrix(\"shadow\", ortho());\n            shadowShader.setInt(\"sampler\", 0);\n            shadowShader.setInt(\"shadowMap\", 1);\n            shadowShader.setFloat(\"c\", c);\n            shadowShader.draw(models);\n            requestAnimationFrame(timestamp => renderFrame(timestamp));\n        }\n        requestAnimationFrame(timestamp => renderFrame(timestamp));\n    });\n}\nMain(\"canvas\");\n\n\n//# sourceURL=webpack://next3d/./app/index.ts?");

/***/ }),

/***/ "./lib/algebra.ts":
/*!************************!*\
  !*** ./lib/algebra.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"apply\": () => (/* binding */ apply),\n/* harmony export */   \"compose\": () => (/* binding */ compose),\n/* harmony export */   \"cross\": () => (/* binding */ cross),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"getIdentity\": () => (/* binding */ getIdentity),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"lookAt\": () => (/* binding */ lookAt),\n/* harmony export */   \"minus\": () => (/* binding */ minus),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"orthogonal\": () => (/* binding */ orthogonal),\n/* harmony export */   \"perspective\": () => (/* binding */ perspective),\n/* harmony export */   \"plus\": () => (/* binding */ plus),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"rotateAroundAxisAngle\": () => (/* binding */ rotateAroundAxisAngle),\n/* harmony export */   \"slerp\": () => (/* binding */ slerp),\n/* harmony export */   \"times\": () => (/* binding */ times),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"zoom\": () => (/* binding */ zoom)\n/* harmony export */ });\nfunction getIdentity() {\n    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction multiply(left, right) {\n    return [\n        left[0x0] * right[0x0] + left[0x4] * right[0x1] + left[0x8] * right[0x2] + left[0xc] * right[0x3],\n        left[0x1] * right[0x0] + left[0x5] * right[0x1] + left[0x9] * right[0x2] + left[0xd] * right[0x3],\n        left[0x2] * right[0x0] + left[0x6] * right[0x1] + left[0xa] * right[0x2] + left[0xe] * right[0x3],\n        left[0x3] * right[0x0] + left[0x7] * right[0x1] + left[0xb] * right[0x2] + left[0xf] * right[0x3],\n        left[0x0] * right[0x4] + left[0x4] * right[0x5] + left[0x8] * right[0x6] + left[0xc] * right[0x7],\n        left[0x1] * right[0x4] + left[0x5] * right[0x5] + left[0x9] * right[0x6] + left[0xd] * right[0x7],\n        left[0x2] * right[0x4] + left[0x6] * right[0x5] + left[0xa] * right[0x6] + left[0xe] * right[0x7],\n        left[0x3] * right[0x4] + left[0x7] * right[0x5] + left[0xb] * right[0x6] + left[0xf] * right[0x7],\n        left[0x0] * right[0x8] + left[0x4] * right[0x9] + left[0x8] * right[0xa] + left[0xc] * right[0xb],\n        left[0x1] * right[0x8] + left[0x5] * right[0x9] + left[0x9] * right[0xa] + left[0xd] * right[0xb],\n        left[0x2] * right[0x8] + left[0x6] * right[0x9] + left[0xa] * right[0xa] + left[0xe] * right[0xb],\n        left[0x3] * right[0x8] + left[0x7] * right[0x9] + left[0xb] * right[0xa] + left[0xf] * right[0xb],\n        left[0x0] * right[0xc] + left[0x4] * right[0xd] + left[0x8] * right[0xe] + left[0xc] * right[0xf],\n        left[0x1] * right[0xc] + left[0x5] * right[0xd] + left[0x9] * right[0xe] + left[0xd] * right[0xf],\n        left[0x2] * right[0xc] + left[0x6] * right[0xd] + left[0xa] * right[0xe] + left[0xe] * right[0xf],\n        left[0x3] * right[0xc] + left[0x7] * right[0xd] + left[0xb] * right[0xe] + left[0xf] * right[0xf],\n    ];\n}\nfunction invert(R) {\n    const n = 4;\n    const m = 8;\n    const augmented = [];\n    for (let i = 0; i < n; ++i) {\n        augmented[i] = new Array(m).fill(0);\n        for (let j = 0; j < n; ++j) {\n            augmented[i][j] = R[j * n + i];\n        }\n        augmented[i][i + n] = 1.0;\n    }\n    for (let i = 0; i < n; ++i) {\n        let pivot = i;\n        for (let j = i + 1; j < n; ++j) {\n            if (Math.abs(augmented[j][i]) > Math.abs(augmented[pivot][i])) {\n                pivot = j;\n            }\n        }\n        if (Math.abs(augmented[pivot][i]) < Number.EPSILON)\n            continue;\n        if (pivot != i) {\n            for (let j = i; j < m; ++j) {\n                const t = augmented[i][j];\n                augmented[i][j] = augmented[pivot][j];\n                augmented[pivot][j] = t;\n            }\n        }\n        for (let j = i + 1; j < m; ++j) {\n            augmented[i][j] /= augmented[i][i];\n        }\n        for (let j = 0; j < n; ++j) {\n            if (j == i)\n                continue;\n            for (let k = i + 1; k < m; ++k) {\n                augmented[j][k] -= augmented[i][k] * augmented[j][i];\n            }\n        }\n    }\n    return [\n        augmented[0][4], augmented[1][4], augmented[2][4], augmented[3][4],\n        augmented[0][5], augmented[1][5], augmented[2][5], augmented[3][5],\n        augmented[0][6], augmented[1][6], augmented[2][6], augmented[3][6],\n        augmented[0][7], augmented[1][7], augmented[2][7], augmented[3][7]\n    ];\n}\nfunction apply(R, v) {\n    return [\n        R[0] * v[0] + R[4] * v[1] + R[0x08] * v[2] + R[12] * v[3],\n        R[1] * v[0] + R[5] * v[1] + R[0x09] * v[2] + R[13] * v[3],\n        R[2] * v[0] + R[6] * v[1] + R[0x0a] * v[2] + R[14] * v[3],\n        R[3] * v[0] + R[7] * v[1] + R[0x0b] * v[2] + R[15] * v[3]\n    ];\n}\nfunction zoom(scale) {\n    return [\n        scale[0], 0, 0, 0,\n        0, scale[1], 0, 0,\n        0, 0, scale[2], 0,\n        0, 0, 0, 1\n    ];\n}\nfunction rotate(rotation) {\n    const x2 = rotation[0] + rotation[0];\n    const y2 = rotation[1] + rotation[1];\n    const z2 = rotation[2] + rotation[2];\n    const xx2 = x2 * rotation[0];\n    const xy2 = x2 * rotation[1];\n    const xz2 = x2 * rotation[2];\n    const xw2 = x2 * rotation[3];\n    const yy2 = y2 * rotation[1];\n    const yz2 = y2 * rotation[2];\n    const yw2 = y2 * rotation[3];\n    const zz2 = z2 * rotation[2];\n    const zw2 = z2 * rotation[3];\n    return [\n        1 - yy2 - zz2, xy2 + zw2, xz2 - yw2, 0,\n        xy2 - zw2, 1 - xx2 - zz2, yz2 + xw2, 0,\n        xz2 + yw2, yz2 - xw2, 1 - xx2 - yy2, 0,\n        0, 0, 0, 1\n    ];\n}\nfunction translate(translation) {\n    return [\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        translation[0], translation[1], translation[2], 1\n    ];\n}\nfunction compose(scale, rotation, translation) {\n    const x2 = rotation[0] + rotation[0];\n    const y2 = rotation[1] + rotation[1];\n    const z2 = rotation[2] + rotation[2];\n    const xx2 = x2 * rotation[0];\n    const xy2 = x2 * rotation[1];\n    const xz2 = x2 * rotation[2];\n    const xw2 = x2 * rotation[3];\n    const yy2 = y2 * rotation[1];\n    const yz2 = y2 * rotation[2];\n    const yw2 = y2 * rotation[3];\n    const zz2 = z2 * rotation[2];\n    const zw2 = z2 * rotation[3];\n    return [\n        (1 - yy2 - zz2) * scale[0], (xy2 + zw2) * scale[0], (xz2 - yw2) * scale[0], 0,\n        (xy2 - zw2) * scale[1], (1 - xx2 - zz2) * scale[1], (yz2 + xw2) * scale[1], 0,\n        (xz2 + yw2) * scale[2], (yz2 - xw2) * scale[2], (1 - xx2 - yy2) * scale[2], 0,\n        translation[0], translation[1], translation[2], 1\n    ];\n}\nfunction rotateAroundAxisAngle(axis, radian) {\n    const half = radian / 2;\n    const halfSin = Math.sin(half);\n    const halfCos = Math.cos(half);\n    const quaternion = [...times(normalize(axis), halfSin), halfCos];\n    return rotate(quaternion);\n}\nfunction normalize(a) {\n    const len = Math.sqrt(a.reduce((sum, i) => sum + i * i, 0));\n    return a.map(i => i / len);\n}\nfunction plus(a, b) {\n    return a.map((v, i) => v + b[i]);\n}\nfunction minus(a, b) {\n    return a.map((v, i) => v - b[i]);\n}\nfunction times(a, b) {\n    return a.map(i => i * b);\n}\nfunction cross(a, b) {\n    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\nfunction dot(a, b) {\n    return a.reduce((sum, i, j) => sum + i * b[j], 0);\n}\nfunction orthogonal(left, right, bottom, top, near, far) {\n    return [\n        2 / (right - left), 0, 0, 0,\n        0, 2 / (top - bottom), 0, 0,\n        0, 0, 2 / (near - far), 0,\n        -(right + left) / (right - left), -(top + bottom) / (top - bottom), (far + near) / (near - far), 1\n    ];\n}\nfunction perspective(fov, near, far, aspect) {\n    const f = 1.0 / Math.tan(fov * Math.PI / 360.0);\n    const depthInv = 1.0 / (near - far);\n    return [\n        f / aspect, 0, 0, 0,\n        0, f, 0, 0,\n        0, 0, (near + far) * depthInv, -1,\n        0, 0, near * far * depthInv * 2, 0\n    ];\n}\nfunction lookAt(position, target, up) {\n    const gaze = normalize(minus(position, target));\n    const right = normalize(cross(up, gaze));\n    up = cross(gaze, right);\n    return [\n        right[0], up[0], gaze[0], 0,\n        right[1], up[1], gaze[1], 0,\n        right[2], up[2], gaze[2], 0,\n        -dot(right, position), -dot(up, position), -dot(gaze, position), 1\n    ];\n}\nfunction lerp(previous, next, interpolation) {\n    return next.map((value, index) => {\n        return previous[index] + interpolation * (value - previous[index]);\n    });\n}\nfunction slerp(previous, next, interpolation) {\n    let d = dot(previous, next);\n    if (d < 0.0) {\n        next = next.map(n => { return -n; });\n        d = -d;\n    }\n    if (d > 0.9995) {\n        return normalize(lerp(previous, next, interpolation));\n    }\n    const alpha = Math.acos(d);\n    const beta = interpolation * alpha;\n    const sinAlpha = Math.sin(alpha);\n    const sinBeta = Math.sin(beta);\n    const scaleNextQuat = sinBeta / sinAlpha;\n    const scalePreviousQuat = Math.cos(beta) - d * scaleNextQuat;\n    return next.map((value, index) => scalePreviousQuat * previous[index] + scaleNextQuat * value);\n}\n\n\n//# sourceURL=webpack://next3d/./lib/algebra.ts?");

/***/ }),

/***/ "./lib/camera.ts":
/*!***********************!*\
  !*** ./lib/camera.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Camera\": () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algebra */ \"./lib/algebra.ts\");\n\nclass Camera {\n    constructor() {\n        this.fov = 45;\n        this.near = 0.01;\n        this.far = 10000;\n        this.aspect = 1;\n        this.position = [0, 0, 10];\n        this.target = [0, 0, 0];\n        this.up = [0, 1, 0];\n        this.dirty = true;\n    }\n    setFov(fov) {\n        this.fov = fov;\n        this.dirty = true;\n        return this;\n    }\n    setNear(near) {\n        this.near = near;\n        this.dirty = true;\n        return this;\n    }\n    setFar(far) {\n        this.far = far;\n        this.dirty = true;\n        return this;\n    }\n    setAspect(aspect) {\n        this.aspect = aspect;\n        this.dirty = true;\n        return this;\n    }\n    setPosition(position) {\n        this.position = position;\n        this.dirty = true;\n        return this;\n    }\n    setTarget(target) {\n        this.target = target;\n        this.dirty = true;\n        return this;\n    }\n    setUp(up) {\n        this.up = up;\n        this.dirty = true;\n        return this;\n    }\n    getMatrix() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.matrix = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.multiply)((0,_algebra__WEBPACK_IMPORTED_MODULE_0__.perspective)(this.fov, this.near, this.far, this.aspect), (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.lookAt)(this.position, this.target, this.up));\n        }\n        return this.matrix;\n    }\n    getQuaterinion(radian, axis) {\n        const half = radian / 2;\n        const halfSin = Math.sin(half);\n        const halfCos = Math.cos(half);\n        const quaternion = [...(0,_algebra__WEBPACK_IMPORTED_MODULE_0__.times)(axis, halfSin), halfCos];\n        return (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.rotate)(quaternion);\n    }\n    orbit(radianX, radianY) {\n        const zAxis = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.minus)(this.position, this.target);\n        const xAxis = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.cross)(this.up, zAxis);\n        const yAxis = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.cross)(zAxis, xAxis);\n        const xRotation = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.rotateAroundAxisAngle)(xAxis, radianX);\n        const yRotation = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.rotateAroundAxisAngle)(yAxis, radianY);\n        const rotation = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.multiply)(xRotation, yRotation);\n        const position = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.apply)(rotation, [...this.position, 1]);\n        this.setPosition([position[0], position[1], position[2]]);\n    }\n    setController(canvas) {\n        let leftPressed = false;\n        canvas.addEventListener('mousedown', (event) => {\n            leftPressed = true;\n        });\n        canvas.addEventListener('mouseup', (event) => {\n            leftPressed = false;\n        });\n        canvas.addEventListener('mousemove', (event) => {\n            if (leftPressed) {\n                const radianX = -event.movementY / canvas.height * Math.PI;\n                const radianY = -event.movementX / canvas.width * Math.PI;\n                this.orbit(radianX, radianY);\n            }\n        });\n        const initialDistance = Math.sqrt(((0,_algebra__WEBPACK_IMPORTED_MODULE_0__.minus)(this.position, this.target).reduce((sum, i) => sum + i * i)));\n        const minDistance = initialDistance / 10;\n        canvas.addEventListener('wheel', (event) => {\n            const factor = event.deltaY / canvas.height + 1;\n            const direction = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.minus)(this.position, this.target);\n            const position = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.plus)(this.target, (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.times)(direction, factor));\n            const distance = Math.sqrt(direction.reduce((sum, i) => sum + i * i)) * factor;\n            if (distance >= minDistance) {\n                this.setPosition(position);\n            }\n        });\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://next3d/./lib/camera.ts?");

/***/ }),

/***/ "./lib/light.ts":
/*!**********************!*\
  !*** ./lib/light.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Light\": () => (/* binding */ Light)\n/* harmony export */ });\n/* harmony import */ var _algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algebra */ \"./lib/algebra.ts\");\n/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader */ \"./lib/loader.ts\");\n\n\nclass Light {\n    constructor(intensity = 1, color = [1, 1, 1], position = [0, 0, 0]) {\n        this.intensity = intensity;\n        this.color = color;\n        this.position = position;\n        this.model = _loader__WEBPACK_IMPORTED_MODULE_1__.BasicLoader.loadCube();\n        this.model.matrix = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.multiply)((0,_algebra__WEBPACK_IMPORTED_MODULE_0__.translate)(position), (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.zoom)([0.1, 0.1, 0.1]));\n    }\n    setPosition(position) {\n        this.position = position;\n        this.model.matrix = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.multiply)((0,_algebra__WEBPACK_IMPORTED_MODULE_0__.translate)(position), (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.zoom)([0.1, 0.1, 0.1]));\n        return this;\n    }\n    getColor() {\n        return (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.times)(this.color, this.intensity);\n    }\n}\n\n\n//# sourceURL=webpack://next3d/./lib/light.ts?");

/***/ }),

/***/ "./lib/loader.ts":
/*!***********************!*\
  !*** ./lib/loader.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasicLoader\": () => (/* binding */ BasicLoader),\n/* harmony export */   \"GLTFLoader\": () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var _algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algebra */ \"./lib/algebra.ts\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ \"./lib/model.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst ELEMENT_SIZE = { 'SCALAR': 1, 'VEC2': 2, 'VEC3': 3, 'VEC4': 4, 'MAT2': 4, 'MAT3': 9, 'MAT4': 16 };\nconst COMPONENT_TYPE = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };\nclass GLTFLoader {\n    constructor(gl) {\n        this.gl = gl;\n    }\n    load(uri) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(uri);\n            const buffer = yield fetch(uri).then(response => response.arrayBuffer());\n            const [magic, version, length] = new Uint32Array(buffer.slice(0, 12));\n            if (magic != 1179937895 || version != 2) {\n                console.log(\"Invalid glb\");\n            }\n            const [gltfLength, gltfType] = new Uint32Array(buffer.slice(12, 20));\n            if (gltfType != 1313821514) {\n                console.log(\"Invalid glTF chunk\");\n            }\n            const gltf = JSON.parse(new TextDecoder(\"utf-8\").decode(buffer.slice(20, 20 + gltfLength)));\n            console.log(gltf);\n            const [binLength, binType] = new Uint32Array(buffer.slice(20 + gltfLength, 28 + gltfLength));\n            if (binType != 5130562) {\n                console.log(\"Invalid bin chunk\");\n            }\n            if (gltfLength + binLength + 28 != length) {\n                console.log(\"Invalid length\");\n            }\n            const bin = buffer.slice(28 + gltfLength);\n            const textures = new Array();\n            if (gltf.images !== undefined) {\n                for (const image of gltf.images) {\n                    textures.push(yield this.loadTexture(gltf, bin, image));\n                }\n            }\n            const model = new _model__WEBPACK_IMPORTED_MODULE_1__.Model();\n            gltf.scenes[(_a = gltf.scene) !== null && _a !== void 0 ? _a : 0].nodes.forEach(root => GLTFLoader.parseMeshes(gltf, bin, root, (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.getIdentity)(), textures, model.meshes));\n            return model;\n        });\n    }\n    static parseMeshes(gltf, bin, nodeId, parentTransformation, textures, meshes) {\n        const node = gltf.nodes[nodeId];\n        const translation = node.translation || [0, 0, 0];\n        const rotation = node.rotation || [0, 0, 0, 0];\n        const scale = node.scale || [1, 1, 1];\n        const localTransformation = node.matrix !== undefined ? node.matrix : (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.compose)(scale, rotation, translation);\n        const globalTransformation = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.multiply)(parentTransformation, localTransformation);\n        if (node.mesh !== undefined) {\n            const primitives = GLTFLoader.parsePrimitives(gltf, bin, gltf.meshes[node.mesh].primitives, textures);\n            meshes.push(new _model__WEBPACK_IMPORTED_MODULE_1__.Mesh(primitives, globalTransformation));\n        }\n        if (node.children !== undefined) {\n            node.children.forEach(child => GLTFLoader.parseMeshes(gltf, bin, child, globalTransformation, textures, meshes));\n        }\n    }\n    static parsePrimitives(gltf, bin, primitives, textures) {\n        return primitives.map(primitive => {\n            var _a, _b, _c;\n            const meshPrimitive = new _model__WEBPACK_IMPORTED_MODULE_1__.Primitive();\n            const attributes = primitive.attributes;\n            if (attributes.POSITION !== undefined) {\n                const positions = GLTFLoader.access(gltf, bin, attributes.POSITION);\n                meshPrimitive.setPositions(positions);\n            }\n            if (attributes.TEXCOORD_0 !== undefined) {\n                const texcoords = GLTFLoader.access(gltf, bin, attributes.TEXCOORD_0);\n                meshPrimitive.setTexCoords(texcoords);\n            }\n            if (attributes.NORMAL !== undefined) {\n                const normals = GLTFLoader.access(gltf, bin, attributes.NORMAL);\n                meshPrimitive.setNormals(normals);\n            }\n            if (primitive.indices !== undefined) {\n                const indices = GLTFLoader.access(gltf, bin, primitive.indices);\n                meshPrimitive.setIndices(indices);\n            }\n            let textureIndex = primitive.material !== undefined\n                ? (_b = (_a = gltf.materials[primitive.material].pbrMetallicRoughness) === null || _a === void 0 ? void 0 : _a.baseColorTexture) === null || _b === void 0 ? void 0 : _b.index\n                : undefined;\n            if (textureIndex == undefined) {\n                textureIndex = (_c = gltf.materials[primitive.material].emissiveTexture) === null || _c === void 0 ? void 0 : _c.index;\n            }\n            if (textureIndex !== undefined) {\n                meshPrimitive.setTexture(textures[textureIndex]);\n            }\n            return meshPrimitive;\n        });\n    }\n    static access(gltf, bin, accessorId) {\n        var _a;\n        const accessor = gltf.accessors[accessorId];\n        const bufferView = gltf.bufferViews[accessor.bufferView];\n        const elementSize = ELEMENT_SIZE[accessor.type];\n        const typedArray = COMPONENT_TYPE[accessor.componentType];\n        const unitLength = elementSize * typedArray.BYTES_PER_ELEMENT;\n        const byteStride = bufferView.byteStride || unitLength;\n        let byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);\n        const data = new typedArray(accessor.count * elementSize);\n        for (let i = 0; i < data.length; i += elementSize) {\n            const value = new typedArray(bin, byteOffset, elementSize);\n            for (let j = 0; j < elementSize; ++j) {\n                data[i + j] = value[j];\n            }\n            byteOffset += byteStride;\n        }\n        return new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(accessor.count, elementSize, accessor.componentType, (_a = accessor.normalized) !== null && _a !== void 0 ? _a : false, data);\n    }\n    loadTexture(gltf, bin, image) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const tex = this.gl.createTexture();\n            this.gl.activeTexture(this.gl.TEXTURE0);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, tex);\n            const bufferView = gltf.bufferViews[image.bufferView];\n            const imageBytes = new Uint8Array(bin, (_a = bufferView.byteOffset) !== null && _a !== void 0 ? _a : 0, bufferView.byteLength);\n            const blob = new Blob([imageBytes], { type: image.mimeType });\n            const urlCreator = window.URL || window.webkitURL;\n            const img = new Image();\n            img.src = urlCreator.createObjectURL(blob);\n            yield img.decode();\n            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);\n            this.gl.generateMipmap(this.gl.TEXTURE_2D);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n            return tex;\n        });\n    }\n}\nclass BasicLoader {\n    static loadCube() {\n        const primitive = new _model__WEBPACK_IMPORTED_MODULE_1__.Primitive();\n        primitive.setPositions(new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(24, 3, WebGL2RenderingContext.FLOAT, false, new Float32Array([\n            -1.0, -1.0, 1.0,\n            1.0, -1.0, 1.0,\n            1.0, 1.0, 1.0,\n            -1.0, 1.0, 1.0,\n            -1.0, -1.0, -1.0,\n            -1.0, 1.0, -1.0,\n            1.0, 1.0, -1.0,\n            1.0, -1.0, -1.0,\n            -1.0, 1.0, -1.0,\n            -1.0, 1.0, 1.0,\n            1.0, 1.0, 1.0,\n            1.0, 1.0, -1.0,\n            -1.0, -1.0, -1.0,\n            1.0, -1.0, -1.0,\n            1.0, -1.0, 1.0,\n            -1.0, -1.0, 1.0,\n            1.0, -1.0, -1.0,\n            1.0, 1.0, -1.0,\n            1.0, 1.0, 1.0,\n            1.0, -1.0, 1.0,\n            -1.0, -1.0, -1.0,\n            -1.0, -1.0, 1.0,\n            -1.0, 1.0, 1.0,\n            -1.0, 1.0, -1.0,\n        ])))\n            .setIndices(new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(36, 1, WebGL2RenderingContext.UNSIGNED_INT, false, new Uint32Array([\n            0, 1, 2, 0, 2, 3,\n            4, 5, 6, 4, 6, 7,\n            8, 9, 10, 8, 10, 11,\n            12, 13, 14, 12, 14, 15,\n            16, 17, 18, 16, 18, 19,\n            20, 21, 22, 20, 22, 23,\n        ])));\n        return new _model__WEBPACK_IMPORTED_MODULE_1__.Model([new _model__WEBPACK_IMPORTED_MODULE_1__.Mesh([primitive])]);\n    }\n    static loadPlane(gl) {\n        const texture = gl.createTexture();\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([200, 200, 200, 255]));\n        const primitive = new _model__WEBPACK_IMPORTED_MODULE_1__.Primitive();\n        primitive.setPositions(new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(4, 3, WebGL2RenderingContext.FLOAT, false, new Float32Array([\n            -1.0, 0.0, 1.0,\n            1.0, 0.0, 1.0,\n            1.0, 0.0, -1.0,\n            -1.0, 0.0, -1.0,\n        ])))\n            .setNormals(new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(6, 3, WebGL2RenderingContext.FLOAT, false, new Float32Array([\n            0.0, 1.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 1.0, 0.0\n        ])))\n            .setTexCoords(new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(4, 2, WebGL2RenderingContext.FLOAT, false, new Float32Array([\n            0.0, 0.0,\n            1.0, 0.0,\n            1.0, 1.0,\n            0.0, 1.0\n        ])))\n            .setTexture(texture)\n            .setIndices(new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(6, 1, WebGL2RenderingContext.UNSIGNED_INT, false, new Uint32Array([\n            0, 1, 2, 0, 2, 3,\n        ])));\n        return new _model__WEBPACK_IMPORTED_MODULE_1__.Model([new _model__WEBPACK_IMPORTED_MODULE_1__.Mesh([primitive])]);\n    }\n    static loadQuad(gl) {\n        const primitive = new _model__WEBPACK_IMPORTED_MODULE_1__.Primitive();\n        primitive.setPositions(new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(4, 2, WebGL2RenderingContext.FLOAT, false, new Float32Array([\n            -1.0, -1.0,\n            1.0, -1.0,\n            1.0, 1.0,\n            -1.0, 1.0\n        ])))\n            .setTexCoords(new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(4, 2, WebGL2RenderingContext.FLOAT, false, new Float32Array([\n            0.0, 0.0,\n            1.0, 0.0,\n            1.0, 1.0,\n            0.0, 1.0\n        ])))\n            .setIndices(new _model__WEBPACK_IMPORTED_MODULE_1__.BufferData(6, 1, WebGL2RenderingContext.UNSIGNED_INT, false, new Uint32Array([\n            0, 1, 2, 0, 2, 3,\n        ])));\n        return primitive;\n    }\n}\n\n\n//# sourceURL=webpack://next3d/./lib/loader.ts?");

/***/ }),

/***/ "./lib/model.ts":
/*!**********************!*\
  !*** ./lib/model.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BufferData\": () => (/* binding */ BufferData),\n/* harmony export */   \"Mesh\": () => (/* binding */ Mesh),\n/* harmony export */   \"Model\": () => (/* binding */ Model),\n/* harmony export */   \"Primitive\": () => (/* binding */ Primitive)\n/* harmony export */ });\n/* harmony import */ var _algebra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algebra */ \"./lib/algebra.ts\");\n\nclass Model {\n    constructor(meshes = new Array(), matrix = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.getIdentity)()) {\n        this.meshes = meshes;\n        this.matrix = matrix;\n    }\n}\nclass Mesh {\n    constructor(primitives, matrix = (0,_algebra__WEBPACK_IMPORTED_MODULE_0__.getIdentity)()) {\n        this.primitives = primitives;\n        this.matrix = matrix;\n    }\n}\nclass Primitive {\n    constructor() {\n        this.mode = WebGL2RenderingContext.TRIANGLES;\n        this.vao = null;\n        this.positions = null;\n        this.texcoords = null;\n        this.texture = null;\n        this.normals = null;\n        this.indices = null;\n    }\n    setPositions(bufferData) {\n        this.positions = bufferData;\n        const bbxmin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n        const bbxmax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n        for (let i = 0; i < bufferData.count; i += 3) {\n            for (let j = 0; j < 3; ++j) {\n                const v = bufferData.data[i + j];\n                bbxmin[j] = Math.min(v, bbxmin[j]);\n                bbxmax[j] = Math.max(v, bbxmax[j]);\n            }\n        }\n        return this;\n    }\n    setTexCoords(bufferData) {\n        this.texcoords = bufferData;\n        return this;\n    }\n    setNormals(bufferData) {\n        this.normals = bufferData;\n        return this;\n    }\n    setIndices(bufferData) {\n        this.indices = bufferData;\n        return this;\n    }\n    setTexture(texture) {\n        this.texture = texture;\n        return this;\n    }\n    draw(gl) {\n        if (this.vao === null) {\n            this.enableVAO(gl);\n        }\n        gl.bindVertexArray(this.vao);\n        if (this.texture !== null) {\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, this.texture);\n        }\n        if (this.indices !== null) {\n            gl.drawElements(this.mode, this.indices.count, this.indices.type, 0);\n        }\n        else if (this.positions !== null) {\n            gl.drawArrays(this.mode, 0, this.positions.count);\n        }\n    }\n    enableVAO(gl) {\n        this.vao = gl.createVertexArray();\n        gl.bindVertexArray(this.vao);\n        if (this.positions !== null) {\n            this.enableAttribute(gl, 0, this.positions);\n        }\n        if (this.texcoords !== null) {\n            this.enableAttribute(gl, 1, this.texcoords);\n        }\n        if (this.normals !== null) {\n            this.enableAttribute(gl, 2, this.normals);\n        }\n        if (this.indices !== null) {\n            this.enableIndices(gl, this.indices);\n        }\n    }\n    enableAttribute(gl, index, bufferData) {\n        const vbo = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n        gl.bufferData(gl.ARRAY_BUFFER, bufferData.data, gl.STATIC_DRAW);\n        gl.vertexAttribPointer(index, bufferData.size, bufferData.type, bufferData.normalized, 0, 0);\n        gl.enableVertexAttribArray(index);\n    }\n    enableIndices(gl, bufferData) {\n        const ebo = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, bufferData.data, gl.STATIC_DRAW);\n    }\n}\nclass BufferData {\n    constructor(count, size, type, normalized, data) {\n        this.count = count;\n        this.size = size;\n        this.type = type;\n        this.normalized = normalized;\n        this.data = data;\n    }\n}\n\n\n//# sourceURL=webpack://next3d/./lib/model.ts?");

/***/ }),

/***/ "./lib/shader.ts":
/*!***********************!*\
  !*** ./lib/shader.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BasicShader\": () => (/* binding */ BasicShader),\n/* harmony export */   \"ColorShader\": () => (/* binding */ ColorShader),\n/* harmony export */   \"PhongShader\": () => (/* binding */ PhongShader),\n/* harmony export */   \"Shader\": () => (/* binding */ Shader),\n/* harmony export */   \"ShadowShader\": () => (/* binding */ ShadowShader)\n/* harmony export */ });\nclass Shader {\n    constructor(gl, shaderSourceProvider) {\n        this.gl = gl;\n        this.uniformLocations = new Map;\n        const { vs, fs } = this.compile(gl, shaderSourceProvider);\n        this.program = this.link(gl, vs, fs);\n    }\n    compile(gl, shaderSourceProvider) {\n        const vs = gl.createShader(gl.VERTEX_SHADER);\n        const fs = gl.createShader(gl.FRAGMENT_SHADER);\n        if (vs === null || fs === null) {\n            throw new Error(\"WebGL failed at creating shader\");\n        }\n        gl.shaderSource(vs, shaderSourceProvider.getVertexSource());\n        gl.shaderSource(fs, shaderSourceProvider.getFragementSource());\n        gl.compileShader(vs);\n        gl.compileShader(fs);\n        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n            throw new Error(`WebGL failed at compiling vertex shader ${gl.getShaderInfoLog(vs)}`);\n        }\n        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n            throw new Error(`WebGL failed at compiling fragment shader ${gl.getShaderInfoLog(fs)}`);\n        }\n        return { vs, fs };\n    }\n    link(gl, vs, fs) {\n        const program = gl.createProgram();\n        if (program === null) {\n            throw new Error(\"WebGL failed at creating program\");\n        }\n        gl.attachShader(program, vs);\n        gl.attachShader(program, fs);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            throw new Error(`WebGL failed at linking program ${gl.getProgramInfoLog(program)}`);\n        }\n        return program;\n    }\n    use() {\n        this.gl.useProgram(this.program);\n    }\n    draw(models) {\n        models.forEach(model => {\n            this.setMatrix(\"model\", model.matrix);\n            model.meshes.forEach(mesh => {\n                this.setMatrix(\"mesh\", mesh.matrix);\n                mesh.primitives.forEach(primitive => primitive.draw(this.gl));\n            });\n        });\n    }\n    setMatrix(name, value) {\n        this.gl.uniformMatrix4fv(this.getUniformLocation(name), false, value);\n    }\n    setFloat(name, value) {\n        this.gl.uniform1f(this.getUniformLocation(name), value);\n    }\n    setFloats(name, value) {\n        this.gl.uniform1fv(this.getUniformLocation(name), value);\n    }\n    setVector3(name, value) {\n        this.gl.uniform3fv(this.getUniformLocation(name), value);\n    }\n    setVector4(name, value) {\n        this.gl.uniform4fv(this.getUniformLocation(name), value);\n    }\n    setInt(name, value) {\n        this.gl.uniform1i(this.getUniformLocation(name), value);\n    }\n    getUniformLocation(name) {\n        if (!this.uniformLocations.has(name)) {\n            const location = this.gl.getUniformLocation(this.program, name);\n            if (location === null) {\n                throw new Error(`WebGL failed at locating uniform ${name}`);\n            }\n            this.uniformLocations.set(name, location);\n        }\n        return this.uniformLocations.get(name);\n    }\n}\nclass BasicShader {\n    getVertexSource() {\n        return `#version 300 es\n    layout(location = 0) in vec3 position;\n    layout(location = 1) in vec2 texCoord;\n    layout(location = 2) in vec3 normal;\n    uniform mat4 camera;\n    uniform mat4 model;\n    uniform mat4 mesh;\n    out vec2 uv;\n    out vec3 FragNormal;\n    void main() {\n      gl_Position = camera * model * mesh * vec4(position, 1.0);\n      uv = texCoord;\n      FragNormal = (model * mesh * vec4(normal, 0.0)).xyz;\n    }`;\n    }\n    getFragementSource() {\n        return `#version 300 es\n    precision highp float;\n    in vec2 uv;\n    in vec3 FragNormal;\n    uniform sampler2D sampler;\n    out vec4 FragColor;\n    void main() {\n      FragColor = texture(sampler, uv);\n    }`;\n    }\n}\nclass ColorShader {\n    getVertexSource() {\n        return `#version 300 es\n    layout(location = 0) in vec3 position;\n    uniform mat4 camera;\n    uniform mat4 model;\n    uniform mat4 mesh;\n    void main() {\n      gl_Position = camera * model * mesh * vec4(position, 1.0);\n    }`;\n    }\n    getFragementSource() {\n        return `#version 300 es\n    precision highp float;\n    uniform vec3 color;\n    out vec4 FragColor;\n    void main() {\n      FragColor = vec4(color, 1.0);\n    }`;\n    }\n}\nclass PhongShader {\n    getVertexSource() {\n        return `#version 300 es\n    layout(location = 0) in vec3 position;\n    layout(location = 1) in vec2 texCoord;\n    layout(location = 2) in vec3 normal;\n\n    uniform mat4 camera;\n    uniform mat4 model;\n    uniform mat4 mesh;\n\n    out vec3 vs_position;\n    out vec3 vs_normal;\n    out vec2 vs_texCoord;\n\n    void main() {\n      vec4 modelMeshPos = model * mesh * vec4(position, 1.0);\n      vs_position = modelMeshPos.xyz;\n      vs_normal = mat3(model * mesh) * normal;\n      vs_texCoord = texCoord;\n      gl_Position = camera * modelMeshPos;\n    }`;\n    }\n    getFragementSource() {\n        return `#version 300 es\n    precision highp float;\n    in vec3 vs_position;\n    in vec3 vs_normal;\n    in vec2 vs_texCoord;\n\n    uniform sampler2D sampler;\n    uniform vec3 Kd;\n    uniform vec3 Ks;\n    uniform vec4 lightPos;\n    uniform vec3 lightIntensity;\n    uniform vec3 cameraPos;\n\n    out vec4 FragColor;\n\n    vec3 blinnPhong() {\n      vec3 color = texture(sampler, vs_texCoord).rgb;\n      color = pow(color, vec3(2.2));\n    \n      vec3 ambient = 0.05 * color;\n    \n      vec3 lightDir;\n      if (lightPos.w == 1.0) {\n        lightDir = normalize(lightPos.xyz - vs_position);\n      } else if (lightPos.w == 0.0) {\n        lightDir = normalize(lightPos.xyz);\n      }\n      vec3 normal = normalize(vs_normal);\n      float diff = max(dot(lightDir, normal), 0.0);\n      vec3 light_atten_coff = lightIntensity / pow(length(lightPos.xyz - vs_position), 2.0);\n      vec3 diffuse = diff * light_atten_coff * color;\n    \n      vec3 viewDir = normalize(cameraPos - vs_position);\n      vec3 halfDir = normalize(lightDir + viewDir);\n      float spec = pow(max(dot(halfDir, normal), 0.0), 32.0);\n      vec3 specular = Ks * light_atten_coff * spec;\n    \n      vec3 radiance = (ambient + diffuse + specular);\n      vec3 phongColor = pow(radiance, vec3(1.0 / 2.2));\n      return phongColor;\n    }\n\n    void main() {\n      FragColor = vec4(blinnPhong(), 1.0);\n    }`;\n    }\n}\nclass ShadowShader {\n    getVertexSource() {\n        return `#version 300 es\n    layout(location = 0) in vec3 position;\n    layout(location = 1) in vec2 texCoord;\n    layout(location = 2) in vec3 normal;\n\n    uniform mat4 camera;\n    uniform mat4 model;\n    uniform mat4 mesh;\n    uniform mat4 shadow;\n\n    out vec3 vs_position;\n    out vec3 vs_normal;\n    out vec2 vs_texCoord;\n    out vec4 vs_shadowCoord;\n\n    void main() {\n      vec4 modelMeshPos = model * mesh * vec4(position, 1.0);\n      vs_position = modelMeshPos.xyz;\n      vs_normal = mat3(model * mesh) * normal;\n      vs_texCoord = texCoord;\n      vs_shadowCoord = shadow * modelMeshPos;\n      gl_Position = camera * modelMeshPos;\n    }`;\n    }\n    getFragementSource() {\n        return `#version 300 es\n    precision highp float;\n    in vec3 vs_position;\n    in vec3 vs_normal;\n    in vec2 vs_texCoord;\n    in vec4 vs_shadowCoord;\n\n    uniform sampler2D sampler;\n    uniform sampler2D shadowMap;\n    uniform vec3 Kd;\n    uniform vec3 Ks;\n    uniform vec4 lightPos;\n    uniform vec3 lightIntensity;\n    uniform vec3 cameraPos;\n    uniform float c;\n\n    #define NUM_SAMPLES 20\n    #define NUM_RINGS 10\n    #define PI 3.141592653589793\n    #define PI2 6.283185307179586\n\n    out vec4 FragColor;\n\n    vec3 blinnPhong() {\n      vec3 color = texture(sampler, vs_texCoord).rgb;\n      color = pow(color, vec3(2.2));\n    \n      vec3 ambient = 0.05 * color;\n    \n      vec3 lightDir;\n      if (lightPos.w == 1.0) {\n        lightDir = normalize(lightPos.xyz - vs_position);\n      } else if (lightPos.w == 0.0) {\n        lightDir = normalize(lightPos.xyz);\n      }\n      vec3 normal = normalize(vs_normal);\n      float diff = max(dot(lightDir, normal), 0.0);\n      vec3 light_atten_coff = lightIntensity / pow(length(lightPos.xyz - vs_position), 2.0);\n      vec3 diffuse = diff * light_atten_coff * color;\n    \n      vec3 viewDir = normalize(cameraPos - vs_position);\n      vec3 halfDir = normalize(lightDir + viewDir);\n      float spec = pow(max(dot(halfDir, normal), 0.0), 32.0);\n      vec3 specular = Ks * light_atten_coff * spec;\n\n      vec3 radiance = (ambient + diffuse + specular);\n      vec3 phongColor = pow(radiance, vec3(1.0 / 2.2));\n      return phongColor;\n    }\n\n    void main() {\n      vec3 shadowCoord = vs_shadowCoord.xyz / vs_shadowCoord.w * 0.5 + 0.5;\n      float occluder = texture(shadowMap, shadowCoord.xy).r;\n      float receiver = c * shadowCoord.z;\n      float visibility = clamp(exp(occluder - receiver), 0.0, 1.0);\n      FragColor = vec4(blinnPhong() * visibility, 1.0);\n    }`;\n    }\n}\n\n\n//# sourceURL=webpack://next3d/./lib/shader.ts?");

/***/ }),

/***/ "./lib/shadow.ts":
/*!***********************!*\
  !*** ./lib/shadow.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Shadow)\n/* harmony export */ });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ \"./lib/model.ts\");\n/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader */ \"./lib/shader.ts\");\n\n\nclass Shadow {\n    constructor(gl) {\n        gl.getExtension(\"EXT_color_buffer_float\");\n        gl.getExtension(\"OES_texture_float_linear\");\n        this.kernelSize = 5;\n        this.textureSize = 2048;\n        this.depthShader = new _shader__WEBPACK_IMPORTED_MODULE_1__.Shader(gl, new DepthShaderSource);\n        this.blurShader = new _shader__WEBPACK_IMPORTED_MODULE_1__.Shader(gl, new BlurShaderSource);\n        this.kernel = Shadow.getKernel(this.kernelSize);\n        this.depthFBO = gl.createFramebuffer();\n        this.verticalFBO = gl.createFramebuffer();\n        this.horizontalFBO = gl.createFramebuffer();\n        this.depthTexture = this.initColorTexture(gl);\n        this.verticalTexture = this.initColorTexture(gl);\n        this.horizontalTexture = this.initColorTexture(gl);\n        this.quad = Shadow.getQuad(gl);\n        this.bindDepthTexture(gl, this.depthFBO, this.depthTexture);\n        this.bindColorTexture(gl, this.verticalFBO, this.verticalTexture);\n        this.bindColorTexture(gl, this.horizontalFBO, this.horizontalTexture);\n    }\n    initColorTexture(gl) {\n        const texture = gl.createTexture();\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, this.textureSize, this.textureSize, 0, gl.RED, gl.FLOAT, null);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n    bindDepthTexture(gl, fbo, texture) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        const depthBuffer = gl.createRenderbuffer();\n        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT32F, this.textureSize, this.textureSize);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if (status !== gl.FRAMEBUFFER_COMPLETE) {\n            throw new Error(`WebGL failed at setting framebuffer ${status}`);\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n    }\n    bindColorTexture(gl, fbo, texture) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if (status !== gl.FRAMEBUFFER_COMPLETE) {\n            throw new Error(`WebGL failed at setting framebuffer ${status}`);\n        }\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    }\n    static getQuad(gl) {\n        const quad = new _model__WEBPACK_IMPORTED_MODULE_0__.Primitive();\n        quad.setPositions(new _model__WEBPACK_IMPORTED_MODULE_0__.BufferData(4, 2, gl.FLOAT, false, new Float32Array([\n            -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0\n        ])));\n        quad.setTexCoords(new _model__WEBPACK_IMPORTED_MODULE_0__.BufferData(4, 2, gl.FLOAT, false, new Float32Array([\n            0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0\n        ])));\n        quad.setIndices(new _model__WEBPACK_IMPORTED_MODULE_0__.BufferData(6, 1, gl.UNSIGNED_INT, false, new Uint32Array([\n            0, 1, 2, 0, 2, 3\n        ])));\n        return quad;\n    }\n    static getKernel(kernelSize) {\n        const halfSize = Math.floor(kernelSize / 2);\n        const kernel = new Float32Array(halfSize + 1);\n        const sigma = ((kernelSize - 1) * 0.5 - 1) * 0.3 + 0.8;\n        const negSigmaSquare2 = -2 * sigma * sigma;\n        kernel[0] = 1;\n        let sum = 1;\n        for (let i = 1; i <= halfSize; ++i) {\n            kernel[i] = Math.exp(i * i / negSigmaSquare2);\n            sum += kernel[i] + kernel[i];\n        }\n        for (let i = 0; i <= halfSize; ++i) {\n            kernel[i] /= sum;\n        }\n        return kernel;\n    }\n    cast(gl, caster, ortho, c) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.depthFBO);\n        gl.viewport(0, 0, this.textureSize, this.textureSize);\n        gl.enable(gl.DEPTH_TEST);\n        gl.clearDepth(1.0);\n        gl.clearBufferfv(gl.COLOR, 0, new Float32Array([c, 0, 0, 0]));\n        gl.clear(gl.DEPTH_BUFFER_BIT);\n        this.depthShader.use();\n        this.depthShader.setMatrix(\"camera\", ortho);\n        this.depthShader.setFloat(\"c\", c);\n        this.depthShader.draw(caster);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindTexture(gl.TEXTURE_2D, this.depthTexture);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        return this.blur(gl, c);\n    }\n    blur(gl, c) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.verticalFBO);\n        gl.viewport(0, 0, this.textureSize, this.textureSize);\n        gl.disable(gl.DEPTH_TEST);\n        this.blurShader.use();\n        this.blurShader.setInt(\"shadowMap\", 0);\n        this.blurShader.setInt(\"kernelSize\", this.kernelSize);\n        this.blurShader.setFloats(\"kernel\", this.kernel);\n        this.quad.setTexture(this.depthTexture);\n        this.quad.draw(gl);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.bindTexture(gl.TEXTURE_2D, this.verticalTexture);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        return this.verticalTexture;\n        /*\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.horizontalFBO)\n        this.blurShader.setInt(\"vertical\", 0)\n        this.quad.setTexture(this.verticalTexture)\n        this.quad.draw(gl)\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n        gl.bindTexture(gl.TEXTURE_2D, null)\n        return this.horizontalTexture\n        */\n    }\n}\nclass DepthShaderSource {\n    getVertexSource() {\n        return `#version 300 es\n    layout(location = 0) in vec3 position;\n    uniform mat4 camera;\n    uniform mat4 model;\n    uniform mat4 mesh;\n    void main() {\n      gl_Position = camera * model * mesh * vec4(position, 1.0);\n    }`;\n    }\n    getFragementSource() {\n        return `#version 300 es\n    precision highp float;\n    uniform float c;\n    out vec4 FragColor;\n    void main() {\n      FragColor.r = c * gl_FragCoord.z;\n    }`;\n    }\n}\nclass BlurShaderSource {\n    getVertexSource() {\n        return `#version 300 es\n    layout(location = 0) in vec2 position;\n    layout(location = 1) in vec2 texCoord;\n    out vec2 vs_texCoord;\n    void main() {\n      vs_texCoord = texCoord;\n      gl_Position = vec4(position, 0.0, 1.0);\n    }`;\n    }\n    getFragementSource() {\n        return `#version 300 es\n    precision highp float;\n\n    #define MAX_KERNEL_SIZE 25\n\n    uniform sampler2D shadowMap;\n    uniform bool vertical;\n    uniform int kernelSize;\n    uniform float kernel[MAX_KERNEL_SIZE];\n\n    in vec2 vs_texCoord;\n    out vec4 FragColor;\n\n    float box() {\n      float d0 = texture(shadowMap, vs_texCoord).r;\n      ivec2 texSize = textureSize(shadowMap, 0);\n      vec2 step = 1.0 / vec2(float(texSize.x), float(texSize.y));\n      int halfSize = kernelSize / 2;\n      float sum = 0.0;\n      for (int i = -halfSize; i <= halfSize; ++i) {\n        float dx = float(i) * step.x;\n        for (int j = -halfSize; j <= halfSize; ++j) {\n          float dy = float(j) * step.y;\n          float dk = texture(shadowMap, vs_texCoord + vec2(dx, dy)).r;\n          sum += exp(dk - d0);\n        }\n      }\n      return d0 + log(sum / float(kernelSize * kernelSize));\n    }\n\n    float gaussian() {\n      float d0 = texture(shadowMap, vs_texCoord).r;\n      ivec2 texSize = textureSize(shadowMap, 0);\n      vec2 step = 1.0 / vec2(float(texSize.x), float(texSize.y));\n      int halfSize = kernelSize / 2;\n      float sum = 0.0;\n      for (int i = -halfSize; i <= halfSize; ++i) {\n        float dx = float(i) * step.x;\n        for (int j = -halfSize; j <= halfSize; ++j) {\n          float dy = float(j) * step.y;\n          float dk = texture(shadowMap, vs_texCoord + vec2(dx, dy)).r;\n          sum += kernel[abs(i)] * kernel[abs(j)] * exp(dk - d0);\n        }\n      }\n      return d0 + log(sum);\n    }\n\n    void main() {\n      FragColor.r = gaussian();\n    }`;\n    }\n}\n\n\n//# sourceURL=webpack://next3d/./lib/shadow.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/index.ts");
/******/ 	
/******/ })()
;